\input{../../preamble.tex}
\input{../class_info.tex}
\usepackage{listings}

\sethomeworknumber{2}

\begin{document}

\homeworkheader{\classnameandsection}

\begin{problem}{6.5-7}
  Show how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with
  a priority queue.

  \begin{solution}
    A FIFO queue can be implemented with a min-heap. So that the item enqueued would have a key representing
    the number of items items inserted thus far. So the first item might have a key of 0, the second one would have a key
    of 1 and so on. \\

    In order to process the FIFO queue one could run {\sl extract-min} and get the first item inserted.
    Subsequent {\sl extract-min}s would ensure that the queue is read in a first-in, first-out way. \\

    Conversely, a stack is LIFO, or last-in, last-out and could be implemented as a max-heap.
    Again, the key can be represented by the number of items thus far. So the first item would have a key of 0, the second
    would have a key of 1, the third a key of 2, and so on. To ``pop'' an item off the stack, one simply need
    call extract-max. \\

    Max-heap implementations have been covered extensively in class. But we didn't explicitly cover
    min-heaps. So rather than writing a pseudo-code implementation I wrote it in Ruby (my favorite language) for fun. \\

    \centerline{A Ruby implementation of MinHeap}
    \lstinputlisting[language=Ruby]{/Users/erichmenge/Development/cse/4041/heaps/min_heap.rb}
  \end{solution}
\end{problem}

\begin{problem}{6.5-8}
  The operation HEAP-DELETE(A,i) deletes the item in node i from heap A. Give an implementation of HEAP-DELETE that runs
  in $O(lgn)$ time for an n-element max-heap.
\end{problem}

\begin{problem}{6.5-9}
  Give an $O(nlgk)$-time algorithm to merge k sorted lists into one sorted list, where n is the total number of elements in
  all the input lists. (Hint: Use a min- heap for k-way merging.)
\end{problem}

\begin{problem}{2.3-2}
  Rewrite the MERGE procedure so that it does not use sentinels, instead stopping once either array L or R has had all its
  elements copied back to A and then copying the remainder of the other array back into A.
\end{problem}

\begin{problem}{2.3-3}
Use mathematical induction to show that when $n$ is an exact power of 2, the solution of the recurrence
  $T(n) = \begin{cases}
    2 & \text{if } n = 2 \\
    2T(n/2) + n & \text{if } n = 2^k, \text{for } k >1
  \end{cases}
  $
\end{problem}

\begin{problem}{2.3-4}
  We can express insertion sort as a recursive procedure as follows. In order to sort $A[1\ldots n]$ we recursively sort
  $A[1\ldots n] - 1 $ and then insert $A[n]$ into the sorted array $A[1\ldots n] - 1 $.
  Write a recurrence for the running time of this recursive version of insertion sort.
\end{problem}

\end{document}
