\input{../../preamble.tex}
\input{../class_info.tex}
\usepackage{listings}

\sethomeworknumber{2}

\begin{document}

\homeworkheader{\classnameandsection}

\begin{problem}{6.5-7}
  Show how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with
  a priority queue.

  \begin{solution}
    A FIFO queue can be implemented with a min-heap. So that the item enqueued would have a key representing
    the number of items items inserted thus far. So the first item might have a key of 0, the second one would have a key
    of 1 and so on. \\

    In order to process the FIFO queue one could run {\sl extract-min} and get the first item inserted.
    Subsequent {\sl extract-min}s would ensure that the queue is read in a first-in, first-out way. \\

    Conversely, a stack is LIFO, or last-in, last-out and could be implemented as a max-heap.
    Again, the key can be represented by the number of items thus far. So the first item would have a key of 0, the second
    would have a key of 1, the third a key of 2, and so on. To ``pop'' an item off the stack, one simply need
    call extract-max. \\

    I've implemented the Queue and Stack in Ruby rather than Pseudocode, because Ruby is more fun than pseudocode and
    is as easy to read. Node is a simple class that stores key value pairs and knows how to compare itself to other
    node objects. \\

    \centerline{A Ruby implementation of Queue and Stack}
    \begin{lstlisting}[language=Ruby]
      module Heaps
        class Node
          include Comparable

          attr_accessor :key
          attr_accessor :value

          def initialize(key, value)
            @key = key
            @value = value
          end

          def <=>(obj1)
            key <=> (obj1.respond_to?(:key) ? obj1.key : obj1)
          end
        end
      end

      class Queue
        def initialize
          @queue = Heaps::MinHeap.new
        end

        def enqueue(value)
          @queue.insert Heaps::Node.new(@queue.size, value)
        end

        def dequeue
          @queue.extract_min.value
        end
      end

      class Stack
        def initialize
          @stack = Heaps::MaxHeap.new
        end

        def push(value)
          @stack.insert Heaps::Node.new(@stack.size, value)
        end

        def pop
          @stack.extract_max.value
        end
      end
    \end{lstlisting}
  \end{solution}
\end{problem}

\begin{problem}{6.5-8}
  The operation HEAP-DELETE(A,i) deletes the item in node i from heap A. Give an implementation of HEAP-DELETE that runs
  in $O(\lg n)$ time for an n-element max-heap.
  \begin{solution}
    \begin{figure}[here]
      \caption{Pseudocode representation of heap-delete}
      \centering
      \begin{lstlisting}
        heap-delete(A,i)
          exchange A[i] with A[A.heap-size]
          A.heap-size = A.heap-size - 1
          heapify(A,i)
      \end{lstlisting}
    \end{figure}
    \begin{proof}
      This function moves the item at the bottom of the heap into the position where the item to be deleted is.
      This causes the deletion of the specified item and also breaks the root. The item that was at the bottom now needs
      to move down the heap until it is in the proper position. \\

      Because exchanging two values and decrementing the size of the heap runs in constant time, the only thing that is
      left to consider for run-time is heapify(A, i). \\

      Heapify starts at the position of the broken root down, comparing itself with left and right children
      and swaps if necessary to repair the broken root. Every swap potentially breaks the root below it so it follows this
      path down recursively. In the worst case scenario, the root is broken at the first position. In this case it would
      have to move from the top of the heap all the way to the bottom. So it is $O(h)$. We want a function of $n$.
      $2^h \le n < 2^{h+1}$ so it is $O(\lg n)$, disregarding the floor because its affect is negligeable.
    \end{proof}
  \end{solution}
\end{problem}

\begin{problem}{6.5-9}
  Give an $O(n \text{ lg }k)$-time algorithm to merge k sorted lists into one sorted list, where n is the total number of elements in
  all the input lists. (Hint: Use a min-heap for k-way merging.)

  \begin{solution}
    Luckily the lists are already sorted. So we can take the first (minimum) element from each $k$
    lists and put them in     a new list. We can then run build-heap on that new list which is $O(k)$. We then extract the
    root of the heap which is the     minimum and add it to our final merged list. In its place we put the next smallest
    number from the list     in which it came and run heapify on the root node which is $O(\lg k)$. We have to do this for
    all $n$ elements, so it     is $n$ extract-min operations which gives $O(n \lg k)$. So we end up with $O(k + n \lg k)$.
    This simplifies to $O(n \lg k)$ because the addition of $k$ is insignificant. \\

    \centerline{Algorithm to merge k sorted lists}
    \begin{lstlisting}
      k-merge(*lists)
        merged_sorted_list = []

        data_for_heap = []
        for list in lists do
          data_for_heap << list.first_element
          list.delete_first_element

        data_for_heap.build_heap

        while min = heap[1]
          merged_sorted_list << min
          if min.originating_list.size > 0
            heap[1] = min.originating_list.first_element
            min.originating_list.delete_first_element
            heap.heapify(1)
          else
            # No more in originating list
            heap.extract_min
        return merged_sorted_list
    \end{lstlisting}
  \end{solution}
\end{problem}

\begin{problem}{2.3-2}
  Rewrite the MERGE procedure so that it does not use sentinels, instead stopping once either array L or R has had all its
  elements copied back to A and then copying the remainder of the other array back into A.
\end{problem}

\begin{problem}{2.3-3}
Use mathematical induction to show that when $n$ is an exact power of 2, the solution of the recurrence
  $T(n) = \begin{cases}
    2 & \text{if } n = 2 \\
    2T(n/2) + n & \text{if } n = 2^k, \text{for } k >1
  \end{cases}
  $
\end{problem}

\begin{problem}{2.3-4}
  We can express insertion sort as a recursive procedure as follows. In order to sort $A[1\ldots n]$ we recursively sort
  $A[1\ldots n] - 1 $ and then insert $A[n]$ into the sorted array $A[1\ldots n] - 1 $.
  Write a recurrence for the running time of this recursive version of insertion sort.
\end{problem}

\end{document}
