\input{../../preamble.tex}
\input{../class_info.tex}
\usepackage{listings}

\sethomeworknumber{2}

\begin{document}

\homeworkheader{\classnameandsection}

\begin{problem}{6.5-7}
  Show how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with
  a priority queue.

  \begin{solution}
    A FIFO queue can be implemented with a min-heap. So that the item enqueued would have a key representing
    the number of items items inserted thus far. So the first item might have a key of 0, the second one would have a key
    of 1 and so on. \\

    In order to process the FIFO queue one could run {\sl extract-min} and get the first item inserted.
    Subsequent {\sl extract-min}s would ensure that the queue is read in a first-in, first-out way. \\

    Conversely, a stack is LIFO, or last-in, last-out and could be implemented as a max-heap.
    Again, the key can be represented by the number of items thus far. So the first item would have a key of 0, the second
    would have a key of 1, the third a key of 2, and so on. To ``pop'' an item off the stack, one simply need
    call extract-max. \\

    Max-heap implementations have been covered extensively in class. But we didn't explicitly cover
    min-heaps. So rather than writing a pseudo-code implementation I wrote it in Ruby (my favorite language) for fun. \\

    \centerline{A Ruby implementation of MinHeap}
    \lstinputlisting[language=Ruby]{/Users/erichmenge/Development/cse/4041/lib/heaps/min_heap.rb}
  \end{solution}
\end{problem}

\begin{problem}{6.5-8}
  The operation HEAP-DELETE(A,i) deletes the item in node i from heap A. Give an implementation of HEAP-DELETE that runs
  in $O(lgn)$ time for an n-element max-heap.
  \begin{solution}
    \begin{figure}[here]
      \caption{Pseudocode representation of heap-delete}
      \centering
      \begin{lstlisting}
        heap-delete(A,i)
          exchange A[i] with A[A.heap-size]
          A.heap-size = A.heap-size - 1
          heapify(A,i)
      \end{lstlisting}
    \end{figure}
    \begin{proof}
      This function moves the item at the bottom of the heap into the position where the item to be deleted is.
      This causes the deletion of the specified item and also breaks the root. The item that was at the bottom now needs
      to move down the heap until it is in the proper position. \\

      Because exchanging two values and decrementing the size of the heap runs in constant time, the only thing that is
      left to consider for run-time is heapify(A, i). \\

      Heapify starts at the position of the broken root down, comparing itself with left and right children
      and swaps if necessary to repair the broken root. Every swap potentially breaks the root below it so it follows this
      path down recursively. In the worst case scenario, the root is broken at the first position. In this case it would
      have to move from the top of the heap all the way to the bottom. So it is $O(h)$. We know there are $2^h$ nodes in a
      heap. So $n = 2^h$. Solving for $h$ we have $ h = lg n$ so $O(h) = O(lg n)$.
    \end{proof}
  \end{solution}
\end{problem}

\begin{problem}{6.5-9}
  Give an $O(n \text{ lg }k)$-time algorithm to merge k sorted lists into one sorted list, where n is the total number of elements in
  all the input lists. (Hint: Use a min- heap for k-way merging.)
\end{problem}

\begin{problem}{2.3-2}
  Rewrite the MERGE procedure so that it does not use sentinels, instead stopping once either array L or R has had all its
  elements copied back to A and then copying the remainder of the other array back into A.
\end{problem}

\begin{problem}{2.3-3}
Use mathematical induction to show that when $n$ is an exact power of 2, the solution of the recurrence
  $T(n) = \begin{cases}
    2 & \text{if } n = 2 \\
    2T(n/2) + n & \text{if } n = 2^k, \text{for } k >1
  \end{cases}
  $
\end{problem}

\begin{problem}{2.3-4}
  We can express insertion sort as a recursive procedure as follows. In order to sort $A[1\ldots n]$ we recursively sort
  $A[1\ldots n] - 1 $ and then insert $A[n]$ into the sorted array $A[1\ldots n] - 1 $.
  Write a recurrence for the running time of this recursive version of insertion sort.
\end{problem}

\end{document}
