\input{../../preamble.tex}
\input{../class_info.tex}
\usepackage{listings}

\sethomeworknumber{4}

\begin{document}

\homeworkheader{\classnameandsection}

\begin{problem}{9.2-3}
  Write an iterative version of RANDOMIZED-SELECT.
  \begin{solution}
    I'll implement this in C because I don't use C enough and could use the practice.
    \begin{figure}[H]
      \centering
      \caption{C iterative randomized select}
      \lstinputlisting{problem_1.c}
    \end{figure}
  \end{solution}
\end{problem}

\begin{problem}{9.3-3}
  Show how quicksort can be made to run in $O(n \lg n)$ time in the worst case, assuming that all elements are
  distinct.
  \begin{solution}
    From chapter 7.2 we know that the best-case of quick-sort is $\Theta(n \lg n)$ when partitioned evenly from the
    recurrence $T(n) = 2T(n/2) + \Theta(n)$. So in order to build a quick-sort that runs in $O(n \lg n)$ time we need to
    ensure the partitions are split evenly.

    Since the select algorithm runs in worst case linear time $O(n)$, using that to find the median for use in
    partitionioning instead of the method in chapter 7 will replace $\Theta(n)$ with $O(n)$ giving the recurrence $T(n)
    = 2T(n/2) + O(n) = O(n \lg n)$.
    \begin{figure}[H]
      \centering
      \caption{C implementation of quicksort with select}
      \lstinputlisting{problem_2.c}
    \end{figure}
  \end{solution}
\end{problem}

\begin{problem}{9.3-5}
  Suppose that you have a ``black-box'' worst-case linear-time median subroutine. Give a simple, linear-time algorithm
  that solves the selection problem for an arbitrary order statistic.
  \begin{solution}
    \begin{figure}[H]
      \centering
      \caption{C++ Implementation of linear-time select}
      \lstinputlisting{problem_9_3_5.cpp}
    \end{figure}
    Since the partition algorithm from prior chapters is $O(n)$ and the ``black-box'' median operation is $O(n)$, and
    the select algorithm runs in linear time the total runtime is $O(n)$.
  \end{solution}
\end{problem}

\begin{problem}{9.3-8}
  Let $X[1\ldots n]$ and $Y[1\ldots n]$ be two arrays, each containing $n$ numbers already in sorted order. Give an $O(\lg
  n)$-time algorithm to find the median of all $2n$ elements in arrays $X$ and $Y$.
\end{problem}

\begin{problem}{21.3-2}
  Write a nonrecursive version of FIND-SET with path compression.
  \begin{solution}
    \begin{figure}[H]
      \centering
      \caption{C++ iterative find-set}
      \lstinputlisting{problem_21_3_2.cpp}
    \end{figure}
  \end{solution}
\end{problem}

\begin{problem}{21.3-3}
  Give a sequence of $m$ MAKE-SET, UNION, and FIND-SET operations, $n$ of which are MAKE-SET operations, that takes
  $\Omega(m \lg n)$ time when we use union by rank only.
\end{problem}

\end{document}
