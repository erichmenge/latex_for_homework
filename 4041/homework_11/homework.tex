\input{../../preamble.tex}
\input{../class_info.tex}

\sethomeworknumber{11}

\begin{document}
\homeworkheader{\classnameandsection}

\begin{problem}{25.1-8}
  The FASTER-ALL-PAIRS-SHORTEST-PATHS procedure, as written, requires us to store $\lceil lg(n-1) \rceil$ matrices,
  each with $n^2$ elements, for a total space requirement of $\Theta(n^2 lg n)$. Modify the procedure to require only
  $\Theta(n^2)$ space by using only two $n \times n$ matrices.
  \begin{solution}
    \begin{lstlisting}[mathescape]
    FASTER-ALL-PAIRS-SHORTEST-PATHS(W)
      n = W.rows
      $L'$ = W
      m = 1
      while m < n - 1
        L = $L'$
        $L'$ = EXTEND-SHORTEST-PATHS(L, L)
        m = 2m
      return $L'$
    \end{lstlisting}
    
    \noindent So our two $n \times n$ matrices are $L$ and $L'$.  $L'$ is always the ``working'' matrix.
  \end{solution}
\end{problem}

\begin{problem}{25.2-2}
  Show how to compute the transitive closure using the technique of Section 25.1.
  \begin{solution}
    We can first create a new $ W = n \times n$ matrix where there is an edge weight of 1 for every edge that exists in
    $G$. We can then run the ALL-PAIRS-SHORTEST-PATHS (fast or slow version) from Section 25.1 on $W$. The return value
    of the algorithm is a matrix that stores the transitive closures.  If the path exists the $i,j$ pair will be $1$.
    If the path doesn't exist then it will be $\infty$.
  \end{solution}
\end{problem}

\newpage
\begin{problem}{25.2-3}
  Modify the FLOYD-WARSHALL procedure to compute the $\Pi^{(k)}$ matrices according to equations (25.6) and (25.7).
  Prove rigorously that for all $i \in V$, the predecessor subgraph $G_{\pi,i}$ is a shortest-paths tree with root i.
  \begin{solution}
    \begin{lstlisting}[mathescape]
      FLOYD-WARSHALL(W, $\Pi$)
      n = W.rows
      $D^{(0)}$ = W
      for k = 1 to n
        let $D^{(k)}$ = ($d_{ij}^{(k)}$) be a new $n \times n$ matrix
        let $\Pi^{(k)}$ = ($\pi_{ij}^{(k)}$) be a new $ n\times n$ matrix
        $\pi_{ij}^{(k)}$ = NIL if i = j or $d_{ij}^{(k-1)}$ = $\infty$ 
        for i = 1 to n
          for j = 1 to n
            if $d_{ij}^{(k-1)} > d_{ik}^{(k-1)} + d_{kj}^{(k-1)}$
              $d_{ij}^{(k)} = d_{ik}^{(k-1)} + d_{kj}^{(k-1)}$
              $\pi_{ij}^{(k)} = \pi_{kj}^{(k-1)}$ unless i = j or $d_{ij}^{(k-1)}$ = $\infty$
            else
              $d_{ij}^{(k)} = d_{ij}^{(k-1)}$
              $\pi_{ij}^{(k)} = \pi_{ij}^{(k-1)}$ unless i = j or $d_{ij}^{(k-1)}$ = $\infty$
     return $D^{(n)}$
    \end{lstlisting}
  \end{solution}
\end{problem}

\begin{problem}{25.2-4}
  As it appears above, the Floyd-Warshall algorithm requires $\Theta(n^3)$ space, since we compute $d_{ij}^{(k)}$ for
  $i, j, k = 1, 2, \ldots, n$. Show that the following procedure, which simply drops all the superscripts, is correct,
  and thus only $\Theta(n^2)$ space is required.
  \br
  (Algorithm Omitted)
  \begin{solution}
    In the original algorithm given on page 695 on the book, line 4 creates a new matrix for every run of the loop.
    This matrix is then assigned on line 7 from the previous matrix $(k - 1)$.
    \br
    At the end, only $D^{(n)}$ is returned, so that is really the only matrix we need.
    \br
    Looking at the new algorithm, $d_{ij}$ is set to the minimum of of either $d_{ij}$ or $d_{ik} + d_{kj}$. Because 
    $d_{ij}$ hasn't been assigned yet at the minimum, it passes the old value in and then is assigned the new value.
    This is exactly equivalent to the old algorithm that passes in the $k - 1$ value to get a return value which is then
    assigned to the $k$ value of the matrix.
    \br
    Since the old algorithm does exactly nothing with those old matrices, the new algorithm is safe to just write over
    the top of them and return $D$.
    \br
    Therefore the new algorithm is in fact correct, and saves a bunch of space.
  \end{solution}
\end{problem}

\begin{problem}{25.2-5}
  \begin{solution}
    Yes it is. In the original definition in the book the predecessor will get overwritten on equivalent weights.
    This in effect means that the very last minimum weight (of many equivalent minimum weight paths) will be the one stored.
    It is just as correct to use the definition given in this problem, in which case the first predecessor with minimum
    weight will be the one that is stored, because all subsequent checks even if equal will not cause an overwrite.
    \br
    Since if there are multiple paths of minimum weight, a particular one isn't more valid than the other, it doesn't
    matter whether or not we select the first predecessor of minimum weight, or the last predecessor of minimum weight,
    since they are both shortest paths.
    \br
    Therefore these two methods are both entirely correct.
  \end{solution}
\end{problem}

\begin{problem}{25.2-6}
  How can we use the output of the Floyd-Warshall algorithm to detect the presence of a negative-weight cycle?
  \begin{solution}
    We can check the main diagonal of the output matrix of the algorithm.  If any negative numbers are present then
    there is a negative weight path back to itself (cycle) $D_{i,i}$.
  \end{solution}
\end{problem}

\end{document}
