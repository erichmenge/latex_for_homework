\input{../../preamble.tex}
\input{../class_info.tex}
\usepackage{graphicx}
\usepackage{listings}

\sethomeworknumber{5}

\begin{document}

\homeworkheader{\classnameandsection}

\begin{problem}{21.3-1}
  Redo Exercise 21.2-2 using a disjoint-set forest with union by rank and path compression.
  \begin{solution}
    \begin{figure}[H]
      \centering
      \caption{Structure for disjoint-set forest with path compression after first set of unions}
      \includegraphics[scale=.5]{21_3_1_1.eps}
    \end{figure}
    \begin{figure}[H]
      \centering
      \caption{Structure for disjoint-set forest with path compression after second set of unions}
      \includegraphics[scale=.5]{21_3_1_2.eps}
    \end{figure}
    \begin{figure}[H]
      \centering
      \caption{Structure for disjoint-set forest with path compression after final set of unions}
      \includegraphics[scale=.5]{21_3_1_3.eps}
    \end{figure}
    \begin{figure}[H]
      \centering
      \caption{Structure for disjoint-set forest with path compression after find-set operations}
      \includegraphics[scale=.5]{21_3_1_4.eps}
    \end{figure}
    Find-set(2) and Find-set(9) both return ``1''. In fact any find-set will return ``1'' now because it is the root of
    the tree.
  \end{solution}
\end{problem}

\begin{problem}{21.3-4}
  Suppose that we wish to add the operation PRINT-SET(x), which is given a node x and prints all the members of x's set,
  in any order. Show how we can add just a single attribute to each node in a disjoint-set forest so that PRINT-SET(x)
  takes time linear in the number of members of x's set and the asymptotic running times of the other operations are
  unchanged. Assume that we can print each member of the set in O(1) time.
\end{problem}

\begin{problem}{15.2-2}
  Give a recursive algorithm MATRIX-CHAIN-MULTIPLY(A,s,i,j) that actually performs the optimal matrix-chain
  multiplication, given the sequence of matrices $(A1, A2, \ldots, A_n)$, the $s$ table computed by MATRIX-CHAIN-ORDER, and
  the indices i and j. (The initial call would be MATRIX-CHAIN-MULTIPLY(A,s,1,n).)
  \begin{solution}
    \begin{lstlisting}
      matrix_chain_multiply(a[], s[], i, j)
        if i==j
          return a[i]
        else
          return matrix_multiply(
            matrix_chain_multiply(a, s, i, s[i][j]),
            matrix_chain_multiply(a, s, s[i][j] + 1, j)
          )
        end
    \end{lstlisting}
  \end{solution}
\end{problem}

\begin{problem}{15.2-4}
  Describe the subproblem graph for matrix-chain multiplication with an input chain of length $n$. How many vertices
  does it have? How many edges does it have, and which edges are they?
\end{problem}

\begin{problem}{15.3-2}
  Draw the recursion tree for the MERGE-SORT procedure from Section 2.3.1 on an array of 16 elements. Explain why
  memoization fails to speed up a good divide-and-conquer algorithm such as MERGE-SORT.
  \begin{solution}
    \begin{figure}[H]
      \centering
      \caption{Recursion map for merge-sort with 16 elements.}
      \includegraphics[scale=.35]{15_3_2.eps}
    \end{figure}
    Memoization is a technique used when recursive paths would otherwise be followed more than once. Merge-sort splits
    the array in half each level of recursion, and then each split is visited, and so on until the individual nodes are
    reached. Since each split needs to return before merge-sort returns (down to the individual nodes), each path is
    only visited once.
  \end{solution}
\end{problem}

\begin{problem}{15.3-3}
  Consider a variant of the matrix-chain multiplication problem in which the goal is to parenthesize the sequence of
  matrices so as to maximize, rather than minimize, the number of scalar multiplications. Does this problem exhibit
  optimal substructure?
\end{problem}

\end{document}
